# Controllers

```elixir
Mix.install([:bonny])

Application.put_env(:bonny, :group, "example.com")
Application.put_env(:bonny, :operator_name, "livebook-operator")
```

## A simple controller

Name the controller like the `kind` of the kubernetes resource it processes.

### Actions

Your controller implements the `behaviour` defined in `Bonny.ControllerV2`. It therefore has to implement callbacks for the actions. Per default there are two functions to implement:

* `apply/1` - Called upon the resource's creation, modification or reconciliation.
* `delete/1` - Called upon the resource's deletion.

However, if you want more fine graned control over the four actions, you can alternatively implement all the action callbacks:

* `add/1` - Called upon the resource's creation.
* `delete/1` - Called upon the resource's deletion.
* `modify/1` - Called upon the resource's modification.
* `reconcile/1` - Called on a regular basis in case we missed an action or state diverges.

```elixir
defmodule Apple do
  use Bonny.ControllerV2

  @impl true
  def apply(resource), do: IO.inspect(resource)

  @impl true
  def delete(resource), do: IO.inspect(resource)

  # These are default implemenations of add, modify and reoncile

  def add(resource), do: apply(resource)
  def modify(resource), do: apply(resource)
  def reconcnile(resource), do: apply(resource)
end
```

## RBAC Rules

Your controller might need special permissions on the kubernetes cluster. Maybe it needs to be able to read secrets. Or it has to be able to create pods. These permissions need to be reflected in the final manifest generated by `mix bonny.gen.manifest` through RBAC rules.

You can define such rules one by one using the `rbac_rule` option when using `Bonny.ControllerV2`. These rules have to be defined as a tuple in the form `{apiGroup :: binary(), resources :: list(), verb :: list()}`:

```elixir
defmodule Pear do
  use Bonny.ControllerV2,
    rbac_rule: {"", ["secrets"], ["get", "watch", "list"]},
    rbac_rule: {"v1", ["pods"], ["get", "watch", "list"]}

  @impl true
  def apply(resource), do: IO.inspect(resource)

  @impl true
  def delete(resource), do: IO.inspect(resource)
end

# When generating the manifest, an auto-generated function `rules/0` is called.
Pear.rules()
```

## Custom Resource Definition (CRD)

The controller creates a default CRD from the information it's got, being the module name and some variables defined in `config.exs`. This CRD is used to generate the manifest when running `mix bonny.gen.manifest`. The default CRD for our `Apple` controller looks as follows:

```elixir
Apple.crd() |> Bonny.CRDV2.to_manifest()
```

As you can see, the CRD contains one single version with the default name of "v1" and a very generic OpenAPIV3Schema which allows the spec to be an arbitrary object. If you would like to add additional printer columns or define a more specific schema and profit from kubernetes' input validation, you can implement `customize_crd/1` in your controller:

```elixir
defmodule DatabaseUser do
  use Bonny.ControllerV2

  @impl true
  def apply(resource), do: IO.inspect(resource)

  @impl true
  def delete(resource), do: IO.inspect(resource)

  @impl true
  @spec customize_crd(Bonny.CRDV2.t()) :: Bonny.CRDV2.t()
  def customize_crd(crd) do
    open_api_schema = %{
      openAPIV3Schema: %{
        type: :object,
        properties: %{
          spec: %{
            type: :object,
            properties: %{
              username: %{type: :string},
              max_conn: %{
                type: :integer,
                description: "Maximum of simultaneos connections allowed for this user."
              }
            }
          }
        }
      }
    }

    struct!(
      crd,
      versions: [
        Bonny.CRD.Version.new!(
          name: "v1",
          additionalPrinterColumns: [
            %{name: "username", type: "string", jsonPath: ".spec.username"},
            %{
              name: "connections",
              type: "integer",
              jsonPath: ".spec.max_conn",
              description: "Maximum of simultaneos connections allowed for this user."
            }
          ],
          schema: open_api_schema
        ),
        Bonny.CRD.Version.new!(name: "v1beta1", schema: open_api_schema, storage: false)
      ]
    )
  end
end

DatabaseUser.crd() |> Bonny.CRDV2.to_manifest()
```
