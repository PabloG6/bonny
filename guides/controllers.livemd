# Controllers

```elixir
Mix.install([{:bonny, path: "/Users/mruoss/src/community/bonny"}])

Application.put_env(:bonny, :group, "example.com")
Application.put_env(:bonny, :operator_name, "livebook-operator")
```

## Creating a Simple Controller

Use `mix bonny.gen.controller KindOfYourResource` to create a controller.

Your controller implements the `behaviour` defined in `Bonny.ControllerV2`. It therefore has to implement the following action callbacks to handle the events:

- `add/1` - Called upon the resource's creation.
- `delete/1` - Called upon the resource's deletion.
- `modify/1` - Called upon the resource's modification.
- `reconcile/1` - Called on a regular basis in case we missed an action or state diverges.

If you used `mix bonny.gen.controller` to create the controller, `add/1` and `modify/1` are delegated to a function `apply/1`. Feel free to change this default behaviour.

```elixir
defmodule Apple do
  use Bonny.ControllerV2

  @impl true
  def add(resource),
    # Do your work (e.g. create further resources)
    do: IO.inspect(resource)

  @impl true
  def modify(resource),
    # Do your work (e.g. create further resources)
    do: IO.inspect(resource)

  @impl true
  def delete(resource),
    #  Clean up
    do: IO.inspect(resource)

  @impl true
  def reconcile(resource),
    # fix deviated state
    do: IO.inspect(resource)
end
```

### Features when creating further resources

If your controller creates other resources for your custom resource (e.g. pods, services,...), it is best practice to reference the owner(s). In kubernetes, you do this by adding an entry to `.metadata.ownerReferences`. In your controller's action callbacks, you can use `add_owner_reference/2` for this:

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Orange do
  use Bonny.ControllerV2

  @impl true
  def add(resource) do
    %{
      "apiVersion" => "v1",
      "kind" => "Pod",
      "metadata" => %{"name" => "nginx", "namespace" => "default"}
      #  ...
    }
    |> add_owner_reference(resource)

    # |> K8s.Client.create()
    # |> then(&(K8s.Client.run(conn(), &1))
  end

  @impl true
  def modify(resource), do: IO.inspect(resource)

  @impl true
  def delete(resource), do: IO.inspect(resource)

  @impl true
  def reconcile(resource), do: IO.inspect(resource)
end
```

Let's see the resulting resource:

```elixir
Orange.add(%{
  "apiVersion" => "example.com/v1",
  "kind" => "Orange",
  "metadata" => %{
    "name" => "golden",
    "namespace" => "default",
    "uid" => "e19b6f40-3293-11ed-a261-0242ac120002"
  }
})
```

## RBAC Rules

Your controller might need special permissions on the kubernetes cluster. Maybe it needs to be able to read secrets. Or it has to be able to create pods. These permissions need to be reflected in the final manifest generated by `mix bonny.gen.manifest` through RBAC rules.

You can define such rules one by one using the `rbac_rule` option when using `Bonny.ControllerV2`. These rules have to be defined as a tuple in the form `{apiGroup :: binary(), resources :: list(), verb :: list()}`:

```elixir
defmodule Pear do
  use Bonny.ControllerV2,
    rbac_rule: {"", ["secrets"], ["get", "watch", "list"]},
    rbac_rule: {"v1", ["pods"], ["get", "watch", "list"]}

  @impl true
  def add(resource), do: IO.inspect(resource)

  @impl true
  def modify(resource), do: IO.inspect(resource)

  @impl true
  def delete(resource), do: IO.inspect(resource)

  @impl true
  def reconcile(resource), do: IO.inspect(resource)
end

# When generating the manifest, an auto-generated function `rules/0` is called.
Pear.rules()
```

## Custom Resource Definition (CRD)

The controller creates a default CRD from the information it's got, being the module name and some variables defined in `config.exs`. This CRD is used to generate the manifest when running `mix bonny.gen.manifest`. The default CRD for our `Apple` controller looks as follows:

```elixir
Apple.crd() |> Bonny.CRDV2.to_manifest()
```

As you can see, the CRD contains one single version with the default name of "v1" and a very generic OpenAPIV3Schema which allows the spec to be an arbitrary object. If you would like to add additional printer columns or define a more specific schema and profit from kubernetes' input validation, you can implement `customize_crd/1` in your controller.

<!-- livebook:{"break_markdown":true} -->

A simple case where you would just set `additionalPrinterColumns` on the default version:

```elixir
defmodule Peach do
  use Bonny.ControllerV2

  @impl true
  def add(resource), do: IO.inspect(resource)

  @impl true
  def modify(resource), do: IO.inspect(resource)

  @impl true
  def delete(resource), do: IO.inspect(resource)

  @impl true
  def reconcile(resource), do: IO.inspect(resource)

  @impl true
  @spec customize_crd(Bonny.CRDV2.t()) :: Bonny.CRDV2.t()
  def customize_crd(crd) do
    additional_printer_columns = [
      %{name: "color", type: "string", jsonPath: ".spec.color"},
      %{
        name: "ripe",
        type: "boolean",
        jsonPath: ".spec.ripe",
        description: "Indicates whether the fruit is ripe or not."
      }
    ]

    put_in(
      crd,
      [Access.key(:versions), Access.at(0), Access.key(:additionalPrinterColumns)],
      additional_printer_columns
    )
  end
end

Peach.crd() |> Bonny.CRDV2.to_manifest()
```

A more complex case where you redefine the whole CRD including OpenAPIV3Schema:

```elixir
defmodule DatabaseUser do
  use Bonny.ControllerV2

  @impl true
  def add(resource), do: IO.inspect(resource)

  @impl true
  def modify(resource), do: IO.inspect(resource)

  @impl true
  def delete(resource), do: IO.inspect(resource)

  @impl true
  def reconcile(resource), do: IO.inspect(resource)

  @impl true
  @spec customize_crd(Bonny.CRDV2.t()) :: Bonny.CRDV2.t()
  def customize_crd(crd) do
    open_api_schema = %{
      openAPIV3Schema: %{
        type: :object,
        properties: %{
          spec: %{
            type: :object,
            properties: %{
              username: %{type: :string},
              max_conn: %{
                type: :integer,
                description: "Maximum of simultaneos connections allowed for this user."
              }
            }
          }
        }
      }
    }

    struct!(
      crd,
      versions: [
        Bonny.CRD.Version.new!(
          name: "v1",
          additionalPrinterColumns: [
            %{name: "username", type: "string", jsonPath: ".spec.username"},
            %{
              name: "connections",
              type: "integer",
              jsonPath: ".spec.max_conn",
              description: "Maximum of simultaneos connections allowed for this user."
            }
          ],
          schema: open_api_schema
        ),
        Bonny.CRD.Version.new!(name: "v1beta1", schema: open_api_schema, storage: false)
      ]
    )
  end
end

DatabaseUser.crd() |> Bonny.CRDV2.to_manifest()
```

## Skipping Observed Generations

One of the kubernetes operator best practices is observing generations. [This blog post explains it really well.](https://alenkacz.medium.com/kubernetes-operator-best-practices-implementing-observedgeneration-250728868792). It is extremly useful especially when you work with status subresources to not get another `modify` event for updating the status.

Bonny supports skipping observed generations of you set the `skip_observed_generations` option to true (see below). If you do this, `add` and `modify` callbacks are not called if a generation has already been observed before.

Behind the scenes, if you set `skip_observed_generations: true`, Bonny adds the status subresource and a field `.status.observedGeneration` to the stored version in your CRD. At runtime, whenever your action callbacks return `:ok`, Bonny updates the status subresource and sets that field to equal `.metadata.generation`.

```elixir
defmodule Plum do
  use Bonny.ControllerV2,
    skip_observed_generations: true

  @impl true
  def apply(resource), do: IO.inspect(resource)

  @impl true
  def delete(resource), do: IO.inspect(resource)

  @impl true
  def reconcile(resource), do: IO.inspect(resource)
end

Plum.crd() |> Bonny.CRDV2.to_manifest()
```

### Some important remarks

- When enabling skipping of observed generations, you MUST re-generate the manifest using `mix bonny.gen.manifest`.
- Your `apply/1` (and/or `add/1` and `modify/1`) callbacks are not called if you change the metadata of a resource, e.g. labels or annotations (since only changing the spec increments the generation).
- The `reconcile/1` action is meant to "fix" deviated states. Therefore it is always called, even if the reconciled generation has already been observed.
