# Controllers

```elixir
Mix.install([:bonny])

Application.put_env(:bonny, :group, "example.com")
Application.put_env(:bonny, :operator_name, "livebook-operator")
```

## Creating a Simple Controller

Use `mix bonny.gen.controller KindOfYourResource` to create a controller.

Your controller implements the `behaviour` defined in `Bonny.ControllerV2`. It therefore has to implement the callbacks to handle the events. Per default there are two functions to implement:

* `apply/1` - Called upon the resource's creation, modification or reconciliation.
* `delete/1` - Called upon the resource's deletion.
* `reconcile/1` - Called on a regular basis in case we missed an action or state diverges.

If you want more fine-graned control over the four actions, you can implement all the action callbacks:

* `add/1` - Called upon the resource's creation.
* `delete/1` - Called upon the resource's deletion.
* `modify/1` - Called upon the resource's modification.
* `reconcile/1` - Called on a regular basis in case we missed an action or state diverges.

Per default, `add/1` and`modify/1` are all delegated to `apply/1`.

```elixir
defmodule Apple do
  use Bonny.ControllerV2

  @impl true
  def apply(resource),
    # Create subresources or so...
    do: IO.inspect(resource)

  @impl true
  def delete(resource),
    # Â Clean up
    do: IO.inspect(resource)
end
```

## RBAC Rules

Your controller might need special permissions on the kubernetes cluster. Maybe it needs to be able to read secrets. Or it has to be able to create pods. These permissions need to be reflected in the final manifest generated by `mix bonny.gen.manifest` through RBAC rules.

You can define such rules one by one using the `rbac_rule` option when using `Bonny.ControllerV2`. These rules have to be defined as a tuple in the form `{apiGroup :: binary(), resources :: list(), verb :: list()}`:

```elixir
defmodule Pear do
  use Bonny.ControllerV2,
    rbac_rule: {"", ["secrets"], ["get", "watch", "list"]},
    rbac_rule: {"v1", ["pods"], ["get", "watch", "list"]}

  @impl true
  def apply(resource),
    do: IO.inspect(resource)

  @impl true
  def delete(resource),
    do: IO.inspect(resource)

  @impl true
  def reconcile(resource),
    do: IO.inspect(resource)
end

# When generating the manifest, an auto-generated function `rules/0` is called.
Pear.rules()
```

## Custom Resource Definition (CRD)

The controller creates a default CRD from the information it's got, being the module name and some variables defined in `config.exs`. This CRD is used to generate the manifest when running `mix bonny.gen.manifest`. The default CRD for our `Apple` controller looks as follows:

```elixir
Apple.crd() |> Bonny.CRDV2.to_manifest()
```

As you can see, the CRD contains one single version with the default name of "v1" and a very generic OpenAPIV3Schema which allows the spec to be an arbitrary object. If you would like to add additional printer columns or define a more specific schema and profit from kubernetes' input validation, you can implement `customize_crd/1` in your controller.

<!-- livebook:{"break_markdown":true} -->

A simple case where you would just set `additionalPrinterColumns` on the default version:

```elixir
defmodule Peach do
  use Bonny.ControllerV2

  @impl true
  def apply(resource), do: IO.inspect(resource)

  @impl true
  def delete(resource), do: IO.inspect(resource)

  @impl true
  def reconcile(resource), do: IO.inspect(resource)

  @impl true
  @spec customize_crd(Bonny.CRDV2.t()) :: Bonny.CRDV2.t()
  def customize_crd(crd) do
    additional_printer_columns = [
      %{name: "color", type: "string", jsonPath: ".spec.color"},
      %{
        name: "ripe",
        type: "boolean",
        jsonPath: ".spec.ripe",
        description: "Indicates whether the fruit is ripe or not."
      }
    ]

    put_in(
      crd,
      [Access.key(:versions), Access.at(0), Access.key(:additionalPrinterColumns)],
      additional_printer_columns
    )
  end
end

Peach.crd() |> Bonny.CRDV2.to_manifest()
```

A more complex case where you redefine the whole CRD including OpenAPIV3Schema:

```elixir
defmodule DatabaseUser do
  use Bonny.ControllerV2

  @impl true
  def apply(resource), do: IO.inspect(resource)

  @impl true
  def delete(resource), do: IO.inspect(resource)

  @impl true
  def reconcile(resource), do: IO.inspect(resource)

  @impl true
  @spec customize_crd(Bonny.CRDV2.t()) :: Bonny.CRDV2.t()
  def customize_crd(crd) do
    open_api_schema = %{
      openAPIV3Schema: %{
        type: :object,
        properties: %{
          spec: %{
            type: :object,
            properties: %{
              username: %{type: :string},
              max_conn: %{
                type: :integer,
                description: "Maximum of simultaneos connections allowed for this user."
              }
            }
          }
        }
      }
    }

    struct!(
      crd,
      versions: [
        Bonny.CRD.Version.new!(
          name: "v1",
          additionalPrinterColumns: [
            %{name: "username", type: "string", jsonPath: ".spec.username"},
            %{
              name: "connections",
              type: "integer",
              jsonPath: ".spec.max_conn",
              description: "Maximum of simultaneos connections allowed for this user."
            }
          ],
          schema: open_api_schema
        ),
        Bonny.CRD.Version.new!(name: "v1beta1", schema: open_api_schema, storage: false)
      ]
    )
  end
end

DatabaseUser.crd() |> Bonny.CRDV2.to_manifest()
```
